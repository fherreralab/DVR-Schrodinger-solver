var tipuesearch = {"pages":[{"title":" Fortran Program ","text":"Fortran Program DVR This is a reposity that uses Discrete Variable Reprsentation DVR to solve the eigensystem of a diatomic alkali molecule. Developer Info Vanessa Olaya Description.","tags":"home","loc":"index.html"},{"title":"369j.f – Fortran Program","text":"Contents Functions threejsymbol sixj ninej Subroutines factor load store add_sub muls mul divs binom find_prime decomp decomp1 mul_div binom1 delta2 Source Code 369j.f Source Code ! ADKL369j.  UNIFIED APPROACH FOR EXACT CALCULATION OF ANGULAR MOMENTUM !1   COUPLING AND RECOUPLING COEFFICIENTS.  L. WEI. !REF. IN COMP. PHYS. COMMUN. 120 (1999) 222 !The program consists of the following files:! !drive.f\t\tdriver program !369j.f !3j.in\t\t3 files of test data !6j.in !9j.in real * 8 function threejsymbol ( j1 , j2 , j3 , m1 , m2 , m3 ) c c  This program calculates the exact 3j symbols using two kinds of number c  representation: prime number representation for prefactor, and 32768- c  base number representation for summation. The results are tabulated c  when the logical variable \"pprint\" is set to be \"true\". c parameter ( length = 100 , ndim = 301 , base = 3276 8.0 ) real j1 , j2 , j3 , m1 , m2 , m3 logical pprint integer n1 , n2 , n3 , n4 , n5 , n6 , n7 , n8 , n9 , n10 , n11 , n12 integer i1 , i2 , sign , numpwr integer iac ( length ), prod ( length ), sum ( length ) integer init1 ( length ), init2 ( length ), init3 ( length ) integer prime ( ndim ), power ( ndim ), ppower ( ndim ) integer power1 ( ndim ), power2 ( ndim ) integer ppower1 ( ndim ), ppower2 ( ndim ) real * 8 pprod , ssum , factor , cuthi , cutlo common / mc / iac , sign common / pr / prime pprint = . false . c  Set the limits for the maximum and the minimum in the real*8 numbers: c cuthi = 1.0d300 cutlo = 1.0d-300 c c  Check validity of input ? c if ( (( m1 + m2 ) . ne . - m3 ) . or . & ( abs ( m1 ) . gt . j1 ) . or . & ( abs ( m2 ) . gt . j2 ) . or . & ( abs ( j1 - j2 ) . gt . j3 ) . or . & (( j1 + j2 ) . lt . j3 ) ) then thre e jsymbol = 0.d0 else c c  Define some integer constants: c n1 = j1 + j2 - j3 n2 = j1 - j2 + j3 n3 = - j1 + j2 + j3 n4 = j1 - m1 n5 = j1 + m1 n6 = j2 + m2 n7 = j3 + m3 n8 = - j2 + j3 + m1 n9 = - j1 + j3 - m2 n10 = 2 * j1 n11 = 2 * j2 n12 = 2 * j3 c c  DO THE CALCULATION IN THE 32768-BASE NUMBER REPRESENTATION c c  Determine the limits of summation: c i1 = max ( 0 , - n8 , - n9 ) i2 = min ( n1 , n4 , n6 ) c c  Initialization: c call binom ( n1 , i1 , init1 ) call binom ( n2 , n4 - i1 , init2 ) call binom ( n3 , n6 - i1 , init3 ) call load ( init1 ) call mul ( init2 ) call mul ( init3 ) if ( mod ( i1 , 2 ) . ne . 0 ) sign = 0 call store ( prod ) call store ( sum ) c c  Summation: c do 10 k = i1 + 1 , i2 call load ( prod ) call muls ( n1 + 1 - k ) call divs ( k , l1 ) call muls ( n4 + 1 - k ) call divs ( n8 + k , l2 ) call muls ( n6 + 1 - k ) call divs ( n9 + k , l3 ) sign = 1 - sign call store ( prod ) call add_sub ( sum ) call store ( sum ) 10 continue c c  Check whether the sum is zero: c if ( iac ( 1 ) . eq . 2 . and . iac ( 2 ) . eq . 0 ) then threejsymbol = 0.d0 return end if c c  DO THE CALCULATION IN THE PRIME NUMBER REPRESENTATION c c  Find the first ndim-1 prime numbers: c call find_prime () c c  Decompose the sum into the prime number representation as c  completely as possible within the given dimension: c call decomp ( power , k ) c c  Calculate the square of prefactor and its multiplication with the square c  of the part in the sum which has been converted to the prime factors: c call binom1 ( n10 , n2 , power1 , k1 ) call binom1 ( n10 , n5 , power2 , k2 ) call mul_div ( - 1 , power1 , k1 , power2 , k2 , ppower1 , kk1 ) call binom1 ( n11 , n1 , power1 , k1 ) call binom1 ( n11 , n6 , power2 , k2 ) call mul_div ( 1 , ppower1 , kk1 , power1 , k1 , ppower2 , kk2 ) call mul_div ( - 1 , ppower2 , kk2 , power2 , k2 , ppower1 , kk1 ) call binom1 ( n12 , n3 , power1 , k1 ) call binom1 ( n12 , n7 , power2 , k2 ) call mul_div ( 1 , ppower1 , kk1 , power1 , k1 , ppower2 , kk2 ) call mul_div ( - 1 , ppower2 , kk2 , power2 , k2 , ppower1 , kk1 ) call delta2 ( j1 , j2 , j3 , ppower2 , kk2 ) call mul_div ( - 1 , ppower1 , kk1 , ppower2 , kk2 , ppower , kk ) call mul_div ( 1 , ppower , kk , power , k , ppower1 , kk1 ) call mul_div ( 1 , ppower1 , kk1 , power , k , ppower , kk ) c if ( mod ( int ( j1 - j2 - m3 ), 2 ) . ne . 0 ) sign = 1 - sign c c  Tabulation of 3j symbols where the part of prime numbers has been squared: c if ( pprint ) then write ( 6 , * ) \"TABULATION: \" , \" sign \" , sign write ( 6 , * ) \"32768-base number part whose number of digits is\" , & iac ( 1 ) - 1 , \" ,\" write ( 6 , * ) ( iac ( i ), i = iac ( 1 ), 2 , - 1 ) write ( 6 , * ) \"prime part whose number is\" , kk - 1 , \" ,\" write ( 6 , * ) ( ppower ( i ), i = 2 , kk ) end if c c  Exact decimal value of 3j symbol: c numpwr = 0 ssum = 0.0 do 20 i = 2 , iac ( 1 ) factor = iac ( i ) j = 1 do while ( j . le . i - 2 - numpwr ) factor = factor * base if ( factor . le . cuthi ) then j = j + 1 else factor = factor / base do 25 jj = 1 , ( i - 2 - numpwr - j + 1 ) ssum = ssum / base 25 continue numpwr = numpwr + ( i - 2 - numpwr - j + 1 ) j = i - 2 - numpwr + 1 end if end do ssum = ssum + factor if ( ssum . gt . cuthi ) then ssum = ssum / base numpwr = numpwr + 1 end if 20 continue c pprod = 1.0 do 30 i = 2 , kk ieven = abs ( ppower ( i )) / 2 irem = mod ( abs ( ppower ( i )), 2 ) if ( ppower ( i ) . gt . 0 ) then do 33 j = 1 , ieven pprod = pprod * dble ( prime ( i )) if ( pprod . gt . cuthi ) then pprod = pprod / base numpwr = numpwr + 1 end if 33 continue if ( irem . eq . 1 ) then pprod = pprod * dsqrt ( dble ( prime ( i ))) if ( pprod . gt . cuthi ) then pprod = pprod / base numpwr = numpwr + 1 end if end if else if ( ppower ( i ) . lt . 0 ) then do 36 j = 1 , ieven pprod = pprod / dble ( prime ( i )) if ( pprod . lt . cutlo ) then pprod = pprod * base numpwr = numpwr - 1 end if 36 continue if ( irem . eq . 1 ) then pprod = pprod / dsqrt ( dble ( prime ( i ))) if ( pprod . lt . cutlo ) then pprod = pprod * base numpwr = numpwr - 1 end if end if end if 30 continue c threejsymbol = pprod * ssum if ( numpwr . gt . 0 ) then do 40 i = 1 , numpwr threejsymbol = threejsymbol * base 40 continue else if ( numpwr . lt . 0 ) then do 45 i = 1 , - numpwr threejsymbol = threejsymbol / base 45 continue end if if ( sign . eq . 0 ) threejsymbol = - threejsymbol if ( threejsymbol . eq . 0.0 ) write ( 6 , * ) \"The 3j symbol underflows !\" c return end if end c c--------------------------------------------------------------------- c real * 8 function sixj ( a , b , c , d , e , f ) c c  This function calculates the exact 6j symbols using two kinds of number c  representation: prime number representation for prefactor, and 32768- c  base number representation for summation. The results are tabulated c  when the logical variable \"pprint\" is set to be \"true\". c parameter ( length = 100 , ndim = 301 , base = 3276 8.0 ) real a , b , c , d , e , f logical pprint integer abc , aef , bdf , cde , abde , acdf , bcef integer i1 , i2 , k , sign , numpwr integer iac ( length ), prod ( length ), sum ( length ) integer init1 ( length ), init2 ( length ), init3 ( length ), init4 ( length ) integer prime ( ndim ), power ( ndim ) integer power1 ( ndim ), power2 ( ndim ), power3 ( ndim ) integer ppower1 ( ndim ), ppower2 ( ndim ) real * 8 ffactor , pprod , ssum , cuthi , cutlo common / mc / iac , sign common / pr / prime c pprint = . false . c  Set the limits of the maximum and the minimum in the real*8 numbers: c cuthi = 1.0d300 cutlo = 1.0d-300 c c  Check the validity of input ? c if ( a . lt . abs ( b - c ) . or . a . gt . b + c & . or . a . lt . abs ( e - f ) . or . a . gt . e + f & . or . b . lt . abs ( d - f ) . or . b . gt . d + f & . or . c . lt . abs ( d - e ) . or . c . gt . d + e ) then sixj = 0.d0 else c  DO THE SUMMATION IN THE 32768-Base NUMBER REPRESENTATION c c  Define some integer constants: c abc = a + b + c aef = a + e + f bdf = b + d + f cde = c + d + e abde = a + b + d + e + 1 acdf = a + c + d + f + 1 bcef = b + c + e + f + 1 c c  Determine the limits of summation: c i1 = max ( abc , aef , bdf , cde ) i2 = min ( abde - 1 , acdf - 1 , bcef - 1 ) c c  Initialization: c call binom ( i1 + 1 , abc + 1 , init1 ) call binom ( int ( a + b - c ), i1 - cde , init2 ) call binom ( int ( a - b + c ), i1 - bdf , init3 ) call binom ( int ( - a + b + c ), i1 - aef , init4 ) call load ( init1 ) call mul ( init2 ) call mul ( init3 ) call mul ( init4 ) if ( mod ( i1 , 2 ) . ne . 0 ) sign = 0 call store ( prod ) call store ( sum ) c c  Summation: c do 10 k = i1 + 1 , i2 call load ( prod ) call muls ( k + 1 ) call divs ( k - abc , l1 ) call muls ( abde - k ) call divs ( k - cde , l2 ) call muls ( acdf - k ) call divs ( k - bdf , l3 ) call muls ( bcef - k ) call divs ( k - aef , l4 ) sign = 1 - sign call store ( prod ) call add_sub ( sum ) call store ( sum ) 10 continue c c  Check whether the sum is zero: c if ( iac ( 1 ) . eq . 2 . and . iac ( 2 ) . eq . 0 ) then sixj = 0.0 return end if c  DO THE CALCULATION IN THE PRIME NUMBER REPRESENTATION c c  Find the first ndim-1 prime numbers: c call find_prime () c c  Decompose the sum into the prime number representation as c   completely as possible within the given dimension: c call decomp ( power , k ) c c  Calculate the square of prefactor and its multiplication with the square c  of the part in the sum which has been converted to the prime numbers: c call delta2 ( a , e , f , power1 , k1 ) call delta2 ( b , d , f , power2 , k2 ) call mul_div ( 1 , power1 , k1 , power2 , k2 , power3 , k3 ) call mul_div ( - 1 , power , k , power3 , k3 , ppower1 , kk1 ) call delta2 ( a , b , c , power1 , k1 ) call delta2 ( c , d , e , power2 , k2 ) call mul_div ( - 1 , power1 , k1 , power2 , k2 , power3 , k3 ) call mul_div ( 1 , power , k , power3 , k3 , ppower2 , kk2 ) call mul_div ( 1 , ppower1 , kk1 , ppower2 , kk2 , power , k ) c c  Tabulation of 6j symbols where the part of prime numbers has been squared: c if ( pprint ) then write ( 6 , * ) \"TABULATION: \" , \" sign \" , sign write ( 6 , * ) \"32768-base number part whose number of digits is\" , & iac ( 1 ) - 1 , \" ,\" write ( 6 , * ) ( iac ( i ), i = iac ( 1 ), 2 , - 1 ) write ( 6 , * ) \"prime part whose number is\" , k - 1 , \" ,\" write ( 6 , * ) ( power ( i ), i = 2 , k ) end if c c  Exact decimal value of 6j symbol: c numpwr = 0 ssum = 0.0 do 20 i = 2 , iac ( 1 ) ffactor = iac ( i ) j = 1 do while ( j . le . i - 2 - numpwr ) ffactor = ffactor * base if ( ffactor . le . cuthi ) then j = j + 1 else ffactor = ffactor / base do 25 jj = 1 , i - 2 - numpwr - j + 1 ssum = ssum / base 25 continue numpwr = numpwr + ( i - 2 - numpwr - j + 1 ) j = i - 2 - numpwr + 1 end if end do ssum = ssum + ffactor if ( ssum . gt . cuthi ) then ssum = ssum / base numpwr = numpwr + 1 end if 20 continue c pprod = 1.0 do 30 i = 2 , k ieven = abs ( power ( i )) / 2 irem = mod ( abs ( power ( i )), 2 ) if ( power ( i ) . gt . 0 ) then do 33 j = 1 , ieven pprod = pprod * dble ( prime ( i )) if ( pprod . gt . cuthi ) then pprod = pprod / base numpwr = numpwr + 1 end if 33 continue if ( irem . eq . 1 ) then pprod = pprod * dsqrt ( dble ( prime ( i ))) if ( pprod . gt . cuthi ) then pprod = pprod / base numpwr = numpwr + 1 end if end if else if ( power ( i ) . lt . 0 ) then do 36 j = 1 , ieven pprod = pprod / dble ( prime ( i )) if ( pprod . lt . cutlo ) then pprod = pprod * base numpwr = numpwr - 1 end if 36 continue if ( irem . eq . 1 ) then pprod = pprod / dsqrt ( dble ( prime ( i ))) if ( pprod . lt . cutlo ) then pprod = pprod * base numpwr = numpwr - 1 end if end if end if 30 continue c sixj = pprod * ssum if ( numpwr . gt . 0 ) then do 40 i = 1 , numpwr sixj = sixj * base 40 continue else if ( numpwr . lt . 0 ) then do 45 i = 1 , - numpwr sixj = sixj / base 45 continue end if if ( sign . eq . 0 ) sixj = - sixj if ( sixj . eq . 0.0 ) write ( 6 , * ) \"The 6j symbol underflows !\" c return end if end c c------------------------------------------------------------------------------ c real * 8 function ninej ( a , b , c , d , e , f , g , h , j ) c c  This function calculates the exact 9j symbols using two kinds of number c  representation: prime number representation for prefactor, and 32768- c  base number representation for summation. The results are tabulated c  when the logical variable \"pprint\" is set to be \"true\". c parameter ( length = 100 , ndim = 301 , base = 3276 8.0 ) real a , b , c , d , e , f , g , h , j , i1 , i2 , kj logical pprint integer sign , iac ( length ), sum ( length ), numpwr integer init1 ( length ), init2 ( length ), init3 ( length ) integer prime ( ndim ), power ( ndim ), ppower ( ndim ) integer power1 ( ndim ), power2 ( ndim ), power3 ( ndim ) integer ppower1 ( ndim ), ppower2 ( ndim ), ppower3 ( ndim ) real * 8 ffactor , prod , ssum , cuthi , cutlo common / mc / iac , sign common / pr / prime pprint = . false . c  Set the limits of the maximum and the minimum in the real*8 numbers: c cuthi = 1.0d300 cutlo = 1.0d-300 c c  Check validity of input ? c if ( a . gt . ( b + c ) . or . a . lt . abs ( b - c ) & . or . a . gt . ( d + g ) . or . a . lt . abs ( d - g ) & . or . d . gt . ( e + f ) . or . d . lt . abs ( e - f ) & . or . g . gt . ( h + j ) . or . g . lt . abs ( h - j ) & . or . b . gt . ( e + h ) . or . b . lt . abs ( e - h ) & . or . c . gt . ( f + j ) . or . c . lt . abs ( f - j ) ) then nine j = 0.d0 else c c  DO THE SUMMATION IN THE 32768-BASE NUMBER REPRESENTATION c c  Determine the limits of summation: c i1 = amax1 ( abs ( h - d ), abs ( b - f ), abs ( a - j )) i2 = amin1 ( h + d , b + f , a + j ) c c  Initialization of sum as zero and of kj: c sum ( 1 ) = 2 sum ( 2 ) = 0 sum ( 3 ) = 1 kj = i1 c do while ( kj . ge . i1 . and . kj . le . i2 ) call factor ( a , b , c , f , j , kj , init1 ) call factor ( f , d , e , h , b , kj , init2 ) call factor ( h , j , g , a , d , kj , init3 ) call load ( init1 ) call mul ( init2 ) call mul ( init3 ) call muls ( int ( 2 * kj + 1 )) if ( mod ( int ( 2 * kj ), 2 ) . ne . 0 ) sign = 1 - sign call add_sub ( sum ) call store ( sum ) kj = kj + 1.0 end do c c  Check whether the sum is zero: c if ( iac ( 1 ) . eq . 2 . and . iac ( 2 ) . eq . 0 ) then ninej = 0.0 return end if c c  DO THE CALCULATION IN THE PRIME NUMBER REPRESENTATION c c  Find the first ndim-1 prime numbers: c call find_prime () c c  Decompose the sum into the prime number representation as c   completely as possible within the given dimension: c call decomp ( power , k ) c c  Calculate the square of prefactor and its multiplication with the square c  of the part in the sum which has been converted to the prime factors: c call delta2 ( a , b , c , power1 , k1 ) call delta2 ( d , e , f , power2 , k2 ) call delta2 ( g , h , j , power3 , k3 ) call mul_div ( 1 , power1 , k1 , power2 , k2 , ppower1 , kk1 ) call mul_div ( 1 , ppower1 , kk1 , power3 , k3 , ppower2 , kk2 ) call mul_div ( - 1 , power , k , ppower2 , kk2 , ppower , kk ) call delta2 ( a , d , g , power1 , k1 ) call delta2 ( b , e , h , power2 , k2 ) call delta2 ( c , f , j , power3 , k3 ) call mul_div ( 1 , power1 , k1 , power2 , k2 , ppower1 , kk1 ) call mul_div ( 1 , ppower1 , kk1 , power3 , k3 , ppower2 , kk2 ) call mul_div ( - 1 , power , k , ppower2 , kk2 , ppower3 , kk3 ) call mul_div ( 1 , ppower , kk , ppower3 , kk3 , power , k ) c c  Tabulation of 9j symbols where the prime numbers have been squared: c if ( pprint ) then write ( 6 , * ) \"TABULATION: \" , \" sign \" , sign write ( 6 , * ) \"32768-base number part whose number of digits is\" , & iac ( 1 ) - 1 , \" ,\" write ( 6 , * ) ( iac ( i ), i = iac ( 1 ), 2 , - 1 ) write ( 6 , * ) \"prime part whose number is\" , k - 1 , \" ,\" write ( 6 , * ) ( power ( i ), i = 2 , k ) end if c c  Exact decimal value of 9j symbol: c numpwr = 0 ssum = 0.0 do 10 i = 2 , iac ( 1 ) ffactor = iac ( i ) i1 = 1 do while ( i1 . le . i - 2 - numpwr ) ffactor = ffactor * base if ( ffactor . le . cuthi ) then i1 = i1 + 1 else ffactor = ffactor / base do 15 jj = 1 , ( i - 2 - numpwr - i1 + 1 ) ssum = ssum / base 15 continue numpwr = numpwr + ( i - 2 - numpwr - i1 + 1 ) i1 = i - 2 - numpwr + 1 end if end do ssum = ssum + ffactor if ( ssum . gt . cuthi ) then ssum = ssum / base numpwr = numpwr + 1 end if 10 continue c prod = 1.0 do 20 i = 2 , k ieven = abs ( power ( i )) / 2 irem = mod ( abs ( power ( i )), 2 ) if ( power ( i ) . gt . 0 ) then do 23 i1 = 1 , ieven prod = prod * dble ( prime ( i )) if ( prod . gt . cuthi ) then prod = prod / base numpwr = numpwr + 1 end if 23 continue if ( irem . eq . 1 ) then prod = prod * dsqrt ( dble ( prime ( i ))) if ( prod . gt . cuthi ) then prod = prod / base numpwr = numpwr + 1 end if end if else if ( power ( i ) . lt . 0 ) then do 26 i1 = 1 , ieven prod = prod / dble ( prime ( i )) if ( prod . lt . cutlo ) then prod = prod * base numpwr = numpwr - 1 end if 26 continue if ( irem . eq . 1 ) then prod = prod / dsqrt ( dble ( prime ( i ))) if ( prod . lt . cutlo ) then prod = prod * base numpwr = numpwr - 1 end if end if end if 20 continue c ninej = prod * ssum if ( numpwr . gt . 0 ) then do 30 i = 1 , numpwr ninej = ninej * base 30 continue else if ( numpwr . lt . 0 ) then do 35 i = 1 , - numpwr ninej = ninej / base 35 continue end if if ( sign . eq . 0 ) ninej = - ninej if ( ninej . eq . 0.0 ) write ( 6 , * ) \"The 9j symbol underflows !\" c return end if end c c------------------------------------------------------------------------------ c subroutine factor ( a , b , c , d , e , f , sum ) c c  This subroutine calculates the factors in summation steps of 9j symbols c  using 32768-base number representation. c parameter ( length = 100 ) real a , b , c , d , e , f integer abc , aef , bdf , cde , abde , acdf , bcef integer i1 , i2 , sign integer iac ( length ), prod ( length ), sum ( length ) integer init1 ( length ), init2 ( length ), init3 ( length ), init4 ( length ) common / mc / iac , sign c c  Define some integer constants: c abc = a + b + c aef = a + e + f bdf = b + d + f cde = c + d + e abde = a + b + d + e + 1 acdf = a + c + d + f + 1 bcef = b + c + e + f + 1 c c  Determine the limits of summation: c i1 = max ( abc , aef , bdf , cde ) i2 = min ( abde - 1 , acdf - 1 , bcef - 1 ) c c  Initialization: c sign = 1 call binom ( i1 + 1 , aef + 1 , init1 ) call binom ( int ( a + e - f ), i1 - bdf , init2 ) call binom ( int ( a - e + f ), i1 - cde , init3 ) call binom ( int ( - a + e + f ), i1 - abc , init4 ) call load ( init1 ) call mul ( init2 ) call mul ( init3 ) call mul ( init4 ) if ( mod ( i1 , 2 ) . ne . 0 ) sign = 0 call store ( prod ) call store ( sum ) c c  Summation: c do 10 k = i1 + 1 , i2 call load ( prod ) call muls ( k + 1 ) call divs ( k - aef , l1 ) call muls ( abde - k ) call divs ( k - bdf , l2 ) call muls ( acdf - k ) call divs ( k - cde , l3 ) call muls ( bcef - k ) call divs ( k - abc , l4 ) sign = 1 - sign call store ( prod ) call add_sub ( sum ) call store ( sum ) 10 continue c return end c c------------------------------------------------------------------------------ c subroutine load ( ix ) c c  This subroutine loads the array 'ix' to the array 'iac' which are in c  common storage. We use the first element of the array 'iac' to represent c  its length. The sign of 'iac' is positive when 'sign' is equal to 1, and c  negative when it is zero. c parameter ( length = 100 ) integer sign , iac ( length ), ix ( length ) common / mc / iac , sign c do 10 i = 1 , ix ( 1 ) iac ( i ) = ix ( i ) 10 continue sign = ix ( ix ( 1 ) + 1 ) return end c c--------------------------------------------------------------------------- c subroutine store ( ix ) c c  This subroutine stores the array 'iac' to the array 'ix'. Note that the c  element ix(ix(1)+1) represents the sign of 'ix'. c parameter ( length = 100 ) integer sign , iac ( length ), ix ( length ) common / mc / iac , sign c do 10 i = 1 , iac ( 1 ) ix ( i ) = iac ( i ) 10 continue ix ( iac ( 1 ) + 1 ) = sign return end c c--------------------------------------------------------------------------- c subroutine add_sub ( ix ) c c  This subroutine does the algebraic summation of arrays 'iac' and 'ix' and c  then load the resultant as 'iac'. c parameter ( length = 100 ) integer sign , iac ( length ), ix ( length ), a , c common / mc / iac , sign c k = min ( iac ( 1 ), ix ( 1 )) c c  ADD ix WITH iac: c if ( sign . eq . ix ( ix ( 1 ) + 1 )) then c = 0 do 10 i = 2 , k a = iac ( i ) + ix ( i ) + c if ( a . gt . 32767 ) then iac ( i ) = mod ( a , 32768 ) c = 1 else iac ( i ) = a c = 0 end if 10 continue if ( iac ( 1 ) . gt . ix ( 1 )) then do 20 i = k + 1 , iac ( 1 ) a = iac ( i ) + c if ( a . eq . 32768 ) then iac ( i ) = 0 c = 1 else iac ( i ) = a c = 0 end if 20 continue else if ( ix ( 1 ) . gt . iac ( 1 )) then do 30 i = k + 1 , ix ( 1 ) a = ix ( i ) + c if ( a . eq . 32768 ) then iac ( i ) = 0 c = 1 else iac ( i ) = a c = 0 end if 30 continue end if iac ( 1 ) = i - 1 if ( c . eq . 1 ) then if ( i . gt . length ) then write ( * , * ) \"increase the dimension of array: iac !\" stop end if iac ( i ) = 1 iac ( 1 ) = i end if end if c c  SUBTRACT ix FROM iac: c if ( sign . ne . ix ( ix ( 1 ) + 1 )) then if ( iac ( 1 ) . gt . ix ( 1 )) then do 40 i = 2 , k if ( iac ( i ) . ge . ix ( i )) then iac ( i ) = iac ( i ) - ix ( i ) else iac ( i ) = ( iac ( i ) - ix ( i )) + 32768 j = i + 1 do while ( iac ( j ) . eq . 0 ) iac ( j ) = 32767 j = j + 1 end do iac ( j ) = iac ( j ) - 1 end if 40 continue do 50 i = k + 1 , iac ( 1 ) iac ( i ) = iac ( i ) 50 continue else if ( ix ( 1 ) . gt . iac ( 1 )) then iac ( iac ( 1 ) + 1 ) = 0 do 60 i = 2 , k if ( ix ( i ) . ge . iac ( i )) then iac ( i ) = ix ( i ) - iac ( i ) else iac ( i ) = ( ix ( i ) - iac ( i )) + 32768 j = i + 1 do while ( iac ( j ) . eq . 32767 ) iac ( j ) = 0 j = j + 1 end do iac ( j ) = iac ( j ) + 1 end if 60 continue if ( iac ( iac ( 1 ) + 1 ) . eq . 0 ) then do 70 i = k + 1 , ix ( 1 ) iac ( i ) = ix ( i ) 70 continue else j = iac ( 1 ) + 1 do while ( ix ( j ) . eq . 0 ) iac ( j ) = 32767 j = j + 1 end do iac ( j ) = ix ( j ) - 1 do 80 i = j + 1 , ix ( 1 ) iac ( i ) = ix ( i ) 80 continue end if sign = 1 - sign else do while ( iac ( k ) . eq . ix ( k ) . and . k . gt . 1 ) iac ( k ) = 0 k = k - 1 end do if ( k . eq . 1 ) then iac ( 1 ) = 2 iac ( 2 ) = 0 sign = 1 return else iac ( 1 ) = k ix ( k + 1 ) = ix ( ix ( 1 ) + 1 ) ix ( 1 ) = k if ( iac ( k ) . gt . ix ( k )) then do 90 i = 2 , k if ( iac ( i ) . ge . ix ( i )) then iac ( i ) = iac ( i ) - ix ( i ) else iac ( i ) = ( iac ( i ) - ix ( i )) + 32768 j = i + 1 do while ( iac ( j ) . eq . 0 ) iac ( i ) = 32767 j = j + 1 end do iac ( j ) = iac ( j ) - 1 end if 90 continue else if ( ix ( k ) . gt . iac ( k )) then do 100 i = 2 , k if ( ix ( i ) . ge . iac ( i )) then iac ( i ) = ix ( i ) - iac ( i ) else iac ( i ) = ( ix ( i ) - iac ( i )) + 32768 j = i + 1 do while ( iac ( j ) . eq . 32767 ) iac ( j ) = 0 j = j + 1 end do iac ( j ) = iac ( j ) + 1 end if 100 continue sign = 1 - sign end if end if end if m = max ( iac ( 1 ), ix ( 1 )) if ( iac ( m ) . ne . 0 ) then iac ( 1 ) = m else do while ( iac ( m ) . eq . 0 . and . m . gt . 2 ) m = m - 1 end do iac ( 1 ) = m end if end if c return end c c-------------------------------------------------------------------------- c subroutine muls ( n ) c c  This subroutine multiplies 'iac' by an integer n (<32768) and load it as c  'iac'. c parameter ( length = 100 ) integer sign , iac ( length ), a , c , n common / mc / iac , sign c c = 0 do 10 i = 2 , iac ( 1 ) a = iac ( i ) * n + c if ( a . gt . 32767 ) then iac ( i ) = mod ( a , 32768 ) c = a / 32768 else iac ( i ) = a c = 0 end if 10 continue if ( c . ne . 0 ) then if ( i . gt . length ) then write ( * , * ) \"iac overflow !\" stop end if iac ( i ) = c iac ( 1 ) = i end if return end c c-------------------------------------------------------------------------- c subroutine mul ( ix ) c c  This subroutine multiplies 'iac' by array 'ix' and then load the resultant c  as 'iac'. c parameter ( length = 100 ) integer sign , ssign integer iac ( length ), ix ( length ), ix1 ( length ), ix2 ( length ) common / mc / iac , sign c c  Initialization of zero: c ix2 ( 1 ) = 2 ix2 ( 2 ) = 0 ix2 ( 3 ) = 1 c ssign = sign sign = 1 call store ( ix1 ) do 10 i = 2 , ix ( 1 ) call load ( ix1 ) n = ix ( i ) call muls ( n ) do 20 j = iac ( 1 ) + i - 2 , 2 , - 1 if ( j . ge . i ) then iac ( j ) = iac ( j - i + 2 ) else iac ( j ) = 0 end if 20 continue iac ( 1 ) = iac ( 1 ) + i - 2 call add_sub ( ix2 ) call store ( ix2 ) 10 continue call load ( ix2 ) if ( ssign . ne . ix ( ix ( 1 ) + 1 )) then sign = 0 else sign = 1 end if return end c c------------------------------------------------------------------------- c subroutine divs ( n , m ) c c  This subroutine divides 'iac' by an integer n and load the resultant as c  'iac' and remainder as an integer m. c parameter ( length = 100 ) integer sign , n , m , iac ( length ), a , c common / mc / iac , sign c c = 0 do 10 i = iac ( 1 ), 2 , - 1 a = iac ( i ) + c * 32768 if ( n . gt . a ) then iac ( i ) = 0 c = a else iac ( i ) = a / n c = mod ( a , n ) end if 10 continue m = c do while ( iac ( iac ( 1 )) . eq . 0 . and . iac ( 1 ) . gt . 2 ) iac ( 1 ) = iac ( 1 ) - 1 end do return end c c-------------------------------------------------------------------------- c subroutine binom ( n , m , ix ) c c  This subroutine calculates binomial in the 32768-base number representation, c  and the resultant is array 'ix'. c parameter ( length = 100 ) integer sign , n , m , iac ( length ), ix ( length ) common / mc / iac , sign c if ( n . lt . m ) then write ( * , * ) \"The binomial coefficient does not exist !\" stop end if c c  Initialization of one: c ix ( 1 ) = 2 ix ( 2 ) = 1 ix ( 3 ) = 1 c k = min ( m , n - m ) call load ( ix ) do 10 i = 1 , k call muls ( n + 1 - i ) call divs ( i , l ) 10 continue call store ( ix ) return end c c------------------------------------------------------------------------- c subroutine find_prime () c c  This subroutine finds the first ndim-1 prime numbers and store c  them into the array \"prime\" with common storage. Here we assume c  that the first prime number is '1' for convenience. c parameter ( ndim = 301 ) integer prime ( ndim ) common / pr / prime c i = 1 prime ( i ) = 1 k = 1 c do while ( i . le . ndim ) k = k + 1 j = 0 i1 = 2 do while ( i1 . le . k - 1 . and . j . eq . 0 ) if (( float ( k ) / i1 - k / i1 ) . eq . 0.0 ) j = j + 1 i1 = i1 + 1 end do if ( j . eq . 0 ) then i = i + 1 prime ( i ) = k end if end do return end c c------------------------------------------------------------------------------ c subroutine decomp ( power , k ) c c  This subroutine decomposes the non-zero 'iac' into the product of prime c  numbers as completely as possible within the dimension given and store c  them into array \"power\" with dimension k. c parameter ( length = 100 , ndim = 301 ) integer sign , iac ( length ), ix ( length ) integer power ( ndim ), prime ( ndim ) common / mc / iac , sign common / pr / prime c k = 1 power ( k ) = 1 if ( iac ( 1 ) . eq . 2 . and . iac ( 2 ) . eq . 1 ) return c n = 1 call store ( ix ) do while ( ix ( 1 ) . ge . 2 . and . n . lt . ndim ) n = n + 1 m = 0 j = 0 do while ( j . eq . 0 ) call load ( ix ) call divs ( prime ( n ), j ) if ( j . eq . 0 ) then m = m + 1 call store ( ix ) end if end do power ( n ) = m if ( m . gt . 0 ) k = n if ( ix ( 1 ) . eq . 2 . and . ix ( 2 ) . eq . 1 ) then call load ( ix ) return end if end do call load ( ix ) return end c c----------------------------------------------------------------------------- c subroutine decomp1 ( num , power , k ) c c  This subroutine decomposes the integer 'num' into the product of k c  prime numbers, each with power(i) equal to m. Also, suppose this c  decomposition is complete. c parameter ( ndim = 301 ) integer num , num1 , power ( ndim ), prime ( ndim ) common / pr / prime c k = 1 power ( 1 ) = 1 num1 = num if ( num1 . eq . 1 ) return c i = 1 do while ( num1 . gt . 1 . and . i . lt . ndim ) i = i + 1 m = 0 do while ( ( dble ( num1 ) / prime ( i ) - num1 / prime ( i )) . eq . 0.0 ) m = m + 1 num1 = num1 / prime ( i ) end do power ( i ) = m if ( m . gt . 0 ) k = i end do if ( num1 . gt . prime ( ndim )) then write ( * , * ) \"increase ndim !\" stop end if return end c c------------------------------------------------------------------------------ c subroutine mul_div ( p_s , power1 , k1 , power2 , k2 , power , k ) c c  This subroutine does the multiplication (p_s=1) or division (p_s=-1) of two c  arrays of prime numbers and the resultant is stored into the array 'power' c  with dimension k. c integer power1 ( k1 ), power2 ( k2 ), power ( k ), p_s c power ( 1 ) = 1 k = 1 c m = min ( k1 , k2 ) if ( p_s . eq . 1 ) then do 10 i = 2 , m power ( i ) = power1 ( i ) + power2 ( i ) 10 continue else if ( p_s . eq . - 1 ) then do 20 i = 2 , m power ( i ) = power1 ( i ) - power2 ( i ) 20 continue else write ( * , * ) \"Please input 1 or -1 for p_s !\" stop end if c k = m do while ( power ( k ) . eq . 0 ) k = k - 1 end do c if ( k1 . gt . k2 ) then do 30 i = m + 1 , k1 power ( i ) = power1 ( i ) 30 continue k = k1 else if ( k2 . gt . k1 . and . p_s . eq . 1 ) then do 40 i = m + 1 , k2 power ( i ) = power2 ( i ) 40 continue k = k2 else if ( k2 . gt . k1 . and . p_s . eq . - 1 ) then do 50 i = m + 1 , k2 power ( i ) = - power2 ( i ) 50 continue k = k2 end if return end c c------------------------------------------------------------------------------ c subroutine binom1 ( n , m , power , k ) c c  This subroutine calculates the binomial in the prime number representation c  and the resultant is array 'power' with dimension k. c parameter ( ndim = 301 ) integer power ( ndim ), power1 ( ndim ), power2 ( ndim ), ppower ( ndim ) c if ( n . lt . m ) then write ( * , * ) \"The binomial coeficient does not exist !\" stop end if c k = 1 power ( k ) = 1 c if ( n . eq . m . or . m . eq . 0 . or . n . eq . 0 ) return c j = min ( m , n - m ) do 10 i = 1 , j call decomp1 ( n + 1 - i , power1 , k1 ) call decomp1 ( i , power2 , k2 ) call mul_div ( 1 , power , k , power1 , k1 , ppower , kk ) call mul_div ( - 1 , ppower , kk , power2 , k2 , power , k ) 10 continue return end c c--------------------------------------------------------------------------- c subroutine delta2 ( a , b , c , power , k ) c c  This subroutine calculates the reverse of square of 'delta' defined in the c  angular momentum coupling theory in the prime number representation and c  the resultant is stored into array 'power' with dimension k. c parameter ( ndim = 301 ) real a , b , c integer power ( ndim ), ppower ( ndim ) integer power1 ( ndim ), power2 ( ndim ), power3 ( ndim ) c if ( a * b * c . eq . 0 ) then if ( a . eq . 0 ) then call decomp1 ( int ( 2 * b + 1 ), power , k ) else call decomp1 ( int ( 2 * a + 1 ), power , k ) end if else call decomp1 ( int ( a + b + c + 1 ), power1 , k1 ) call binom1 ( int ( a + b + c ), int ( 2 * a ), power2 , k2 ) call binom1 ( int ( 2 * a ), int ( a + b - c ), power3 , k3 ) call mul_div ( 1 , power1 , k1 , power2 , k2 , ppower , kk ) call mul_div ( 1 , ppower , kk , power3 , k3 , power , k ) end if return end","tags":"","loc":"sourcefile/369j.f.html"},{"title":"integration_double.f90 – Fortran Program","text":"Contents Subroutines cubint Source Code integration_double.f90 Source Code subroutine cubint ( ftab , xtab , ntab , ia , ib , result , error ) ! !*********************************************************************** ! !! CUBINT approximates an integral using cubic interpolation of data. ! ! !  Discussion: ! !    The integral to be approximated is ! !      INTEGRAL (XTAB(IB) to XTAB(IA)) F(X) DX ! !    The routine estimates the error in integration. ! !  Reference: ! !    Philip Davis and Philip Rabinowitz, !    Methods of Numerical Integration, !    Blaisdell Publishing, 1967. ! !    P E Gill and G F Miller !    An algorithm for the integration of unequally spaced data, !    Comput J, Number 15, 1972, pages 80-83. ! !  Modified: ! !    30 October 2000 !    19 April 2013 'REAL converted to REAL*8' !  Parameters: ! !    Input, real*8 FTAB(NTAB), contains the tabulated function !    values, FTAB(I) = F(XTAB(I)). ! !    Input, real*8 XTAB(NTAB), contains the points at which the !    function was tabulated.  XTAB should contain distinct !    values, given in ascending order. ! !    Input, integer NTAB, the number of tabulated points. !    NTAB must be at least 4. ! !    Input, integer IA, the entry of XTAB at which integration !    is to begin.  IA must be no less than 1 and no greater !    than NTAB. ! !    Input, integer IB, the entry of XTAB at which integration !    is to end.  IB must be no less than 1 and no greater than !    NTAB. ! !    Output, real*8 RESULT, the approximate value of the !    integral from XTAB(IA) to XTAB(IB) of the function. ! !    Output, real*8 ERROR, an estimate of the error in !    integration. ! implicit none ! integer ntab ! real * 8 c real * 8 d1 real * 8 d2 real * 8 d3 real * 8 error real * 8 ftab ( ntab ) real * 8 h1 real * 8 h2 real * 8 h3 real * 8 h4 integer i integer ia integer ib integer ind integer it integer j integer k real * 8 r1 real * 8 r2 real * 8 r3 real * 8 r4 real * 8 result real * 8 s real * 8 term real * 8 xtab ( ntab ) ! result = 0.0D+00 error = 0.0D+00 if ( ia == ib ) then return end if if ( ntab < 4 ) then write ( * , '(a)' ) ' ' write ( * , '(a)' ) 'CUBINT - Fatal error!' write ( * , '(a,i6)' ) '  NTAB must be at least 4, but input NTAB = ' , ntab stop end if if ( ia < 1 ) then write ( * , '(a)' ) ' ' write ( * , '(a)' ) 'CUBINT - Fatal error!' write ( * , '(a,i6)' ) '  IA must be at least 1, but input IA = ' , ia stop end if if ( ia > ntab ) then write ( * , '(a)' ) ' ' write ( * , '(a)' ) 'CUBINT - Fatal error!' write ( * , '(a,i6)' ) '  IA must be <= NTAB, but input IA=' , ia stop end if if ( ib < 1 ) then write ( * , '(a)' ) ' ' write ( * , '(a)' ) 'CUBINT - Fatal error!' write ( * , '(a,i6)' ) '  IB must be at least 1, but input IB = ' , ib stop end if if ( ib > ntab ) then write ( * , '(a)' ) ' ' write ( * , '(a)' ) 'CUBINT - Fatal error!' write ( * , '(a,i6)' ) '  IB must be <= NTAB, but input IB=' , ib stop end if ! !  Temporarily switch IA and IB, and store minus sign in IND !  so that, while integration is carried out from low X's !  to high ones, the sense of the integral is preserved. ! if ( ia > ib ) then ind = - 1 it = ib ib = ia ia = it else ind = 1 end if s = 0.0D+00 c = 0.0D+00 r4 = 0.0D+00 j = ntab - 2 if ( ia < ntab - 1 . or . ntab == 4 ) then j = max ( 3 , ia ) end if k = 4 if ( ib > 2 . or . ntab == 4 ) then k = min ( ntab , ib + 2 ) - 1 end if do i = j , k if ( i <= j ) then h2 = xtab ( j - 1 ) - xtab ( j - 2 ) d3 = ( ftab ( j - 1 ) - ftab ( j - 2 )) / h2 h3 = xtab ( j ) - xtab ( j - 1 ) d1 = ( ftab ( j ) - ftab ( j - 1 )) / h3 h1 = h2 + h3 d2 = ( d1 - d3 ) / h1 h4 = xtab ( j + 1 ) - xtab ( j ) r1 = ( ftab ( j + 1 ) - ftab ( j )) / h4 r2 = ( r1 - d1 ) / ( h4 + h3 ) h1 = h1 + h4 r3 = ( r2 - d2 ) / h1 if ( ia <= 1 ) then result = h2 * ( ftab ( 1 ) + h2 * ( 0.5D0 * d3 - h2 * ( d2 / 6.0D0 - ( h2 + h3 + h3 ) * r3 / 1 2.D0 ))) s = - h2 ** 3 * ( h2 * ( 3.0D0 * h2 + 5.0D0 * h4 ) + 1 0.0D0 * h3 * h1 ) / 6 0.0d0 end if else h4 = xtab ( i + 1 ) - xtab ( i ) r1 = ( ftab ( i + 1 ) - ftab ( i )) / h4 r4 = h4 + h3 r2 = ( r1 - d1 ) / r4 r4 = r4 + h2 r3 = ( r2 - d2 ) / r4 r4 = ( r3 - d3 ) / ( r4 + h1 ) end if if ( i > ia . and . i <= ib ) then term = h3 * (( ftab ( i ) + ftab ( i - 1 )) * 0.5d0 - h3 * h3 * ( d2 + r2 + ( h2 - h4 ) * r3 ) / 1 2.0d0 ) result = result + term c = h3 ** 3 * ( 2.0d+00 * h3 * h3 + 5.d0 * ( h3 * ( h4 + h2 ) + 2.0d0 * h2 * h4 ) ) / 12 0.0d+00 error = error + ( c + s ) * r4 if ( i /= j ) then s = c else s = s + c + c end if else error = error + r4 * s end if if ( i >= k ) then if ( ib >= ntab ) then term = h4 * ( ftab ( ntab ) - h4 * ( 0.5d0 * r1 + h4 * ( r2 / 6.0d0 + ( h3 + h3 + h4 ) * r3 / 1 2.d0 ))) result = result + term error = error - h4 ** 3 * r4 * & ( h4 * ( 3.0d0 * h4 + 5.0d0 * h2 ) & + 1 0.0d0 * h3 * ( h2 + h3 + h4 ) ) / 6 0.0d+00 end if if ( ib >= ntab - 1 ) error = error + s * r4 else h1 = h2 h2 = h3 h3 = h4 d1 = r1 d2 = r2 d3 = r3 end if end do ! !  Restore original values of IA and IB, reverse signs !  of RESULT and ERROR, to account for integration !  that proceeded from high X to low X. ! if ( ind /= 1 ) then it = ib ib = ia ia = it result = - result error = - error end if return end","tags":"","loc":"sourcefile/integration_double.f90.html"},{"title":"rovib.f90 – Fortran Program","text":"This file depends on sourcefile~~rovib.f90~~EfferentGraph sourcefile~rovib.f90 rovib.f90 sourcefile~unit_conversion.f90 unit_conversion.f90 sourcefile~rovib.f90->sourcefile~unit_conversion.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs rovib Subroutines DVR_radial orthonormal_check dunham Source Code rovib.f90 Source Code program rovib !----------------------------------------------------------------------------------------------------------------- ! \tGeneral program to calculate the rovibrational structure of a diatomic molecule !\tin a given closed-shell electronic potential curve. E(v,J) !----------------------------------------------------------------------------------------------------------------- !\tprogramer\t\tdate\t\t\tcomments !----------------------------------------------------------------------------------------------------------------- !\tF. Herrera\t\tApril 2, 2013\tFirst working version gives energies and wavefunctions. !\t\t\t\t\t\tComputations are done in atomic units. !\tF. Herrera\t\tApril 3, 2013\tAccurate for LiCs X state potential. Transition frequencies for !\t\t\t\t\t\t1st rotational and 1st vibrational quanta are equal to Dunham !\t\t\t\t\t\texpansion in PRA 75,042513 (2007), up to six decimal places. !\t\t\t\t\t\tAccuracy is expected to degrade for highest vibrational states !\t\t\t\t\t\t(v > 20). Systematic improvement possible by including short and !\t\t\t\t\t\tlong range potentials. Molecular species is selected by input. !\t\t\t\t\t\tRadial wavefunctions are orthonormal. !\tF. Herrera\t\tApril 4, 2013\tEvaluates the dipole integral <v'(J')|d|v(J)> between !\t\t\t\t\t\tselected rovibrational states. !----------------------------------------------------------------------------------------------------------------- use unit_conversion_library implicit none ! Main program variables integer :: NGP , i , j , rot , instatus , vmax , NV , NR , PEC integer , parameter :: kmax = 5000 double precision :: NN , Nmax , mass , rmin , rmax , step , RMAT ( kmax , 2 ) double precision , allocatable :: grid (:), potential (:), hamiltonian (:,:), eigenvalues (:), eigenvectors (:,:) double precision , allocatable :: rovib_wavefunctions (:,:,:), rovib_energies (:,:) character :: mol * 4 ! Variables for LAPACK diagonalization double precision , allocatable :: WORK (:), A (:,:) integer , allocatable :: IWORK (:) integer :: LWORK , LIWORK , INFO ! Variables for cubic spline interpolation integer :: mesh double precision :: x , y double precision , allocatable :: knots (:,:), moments (:) real * 8 threejsymbol !----------------------------------------------------------------------------------------------------------------- ! Setting initial parameters for LiCs print * , 'Setting parameters for LiCs' mol = 'LiCs' ! molecule name rmin = 4 d0 ! in Bohr radius rmax = 50 d0 ! in Bohr radius step = 0.01d0 ! in Bohr radius mass = 6.664204432 ! in amu units Nmax = 10 ! maximum rotational angular momentum number N vmax = 16 ! maximum vibrational number v if (( rmax . gt . 51 5.d0 ). or .( rmin . lt . 4.d0 )) stop 'Error: grid boundaries outside potential interval!' ! Convertion to atomic units mass = amu_to_au ( mass ) ! Define parameters NGP = nint ( dabs ( rmax - rmin ) / step ) + 1 ! number of grid points NR = nint ( Nmax ) + 1 ! number of rotational states (for truncation) NV = vmax + 1 ! number of vibrational states (for truncation) ! Read potential curve print * , 'Reading potential energy curve' open ( 20 , file = mol // '_PEC.in' ) mesh = 0 do mesh = mesh + 1 read ( 20 , * , iostat = instatus ) ( RMAT ( mesh , j ), j = 1 , 2 ) if ( instatus . lt . 0 ) exit end do PEC = mesh - 1 if ( PEC . eq . 0 ) stop 'Error: Potencial energy file is empty' allocate ( moments ( PEC )) allocate ( knots ( PEC , 2 )) do i = 1 , PEC knots ( i , 1 ) = RMAT ( i , 1 ) ! Already in au knots ( i , 2 ) = wavenumber_to_hartree ( RMAT ( i , 2 )) ! Convert to atomic units end do call cubicsplines ( knots , PEC , 0.d0 , 0.d0 , moments ) ! Compute moments ! Construction of the DVR Hamiltonian print * , 'Construction of the DVR Hamiltonian' allocate ( grid ( NGP )) allocate ( potential ( NGP )) allocate ( hamiltonian ( NGP , NGP )) allocate ( rovib_wavefunctions ( NR , NGP , NV )) allocate ( rovib_energies ( NR , NV )) LWORK = 1 + 6 * NGP + 2 * NGP ** 2 LIWORK = 3 + 5 * NGP allocate ( WORK ( LWORK )) allocate ( IWORK ( LIWORK )) allocate ( eigenvalues ( NGP )) allocate ( eigenvectors ( NGP , NGP )) allocate ( A ( NGP , NGP )) ! Loop over rotational quantum number print * , 'Begin DVR' do rot = 1 , NR ! Begin loop over rotational states NN = ( rot - 1 ) do i = 1 , NGP x = rmin + dble ( i - 1 ) * step grid ( i ) = x ! Set up uniform grid call splineinterpol ( knots , moments , PEC , x , y ) potential ( i ) = y + NN * ( NN + 1.d0 ) / ( 2.d0 * mass * grid ( i ) * grid ( i )) ! Interpolated electronic + rotational end do ! Evaluate DVR kinetic + potential energies (in atomic units) call DVR_radial ( mass , step , NGP , grid , potential , hamiltonian ) ! Diagonalize the Hamiltonian using LAPACK A = hamiltonian call DSYEVD ( 'V' , 'U' , NGP , A , NGP , eigenvalues , WORK , LWORK , IWORK , LIWORK , INFO ) eigenvectors = A ! Normalize the eigenvectors by the grid step eigenvectors = eigenvectors / dsqrt ( step ) ! Write eigenvectors to 3D array do i = 1 , NGP do j = 1 , NV rovib_wavefunctions ( rot , i , j ) = eigenvectors ( i , j ) end do end do do j = 1 , NV rovib_energies ( rot , j ) = eigenvalues ( j ) end do end do ! End loop over rotational states print * , 'End DVR' deallocate ( knots ) deallocate ( moments ) end program rovib !================================================================================================================================================== !================================================================================================================================================== subroutine DVR_radial ( m , step , NGP , grid , potential , hamiltonian ) ! \tProgram implements a DVR Hamiltonian using a Fourier basis/Uniform grid approach ! \tas described in J. Chem. Phys. 96(3) 1982 (1992). Different boundary conditions are supported. !\tThe general representation in terms of particle-in-a-box eigenfunctions is specialized !\tto the semi-infinite interval (0,infinity), appropriate for a radial coordinate. !\tThe kinetic energy operator includes the mass explicitly. Otherwise the units are hbar = 1 ! !\tINPUT: !\t\t integer \"NGP\": the number of grid points !\t\t double precision \"step\": the grid step (step) !\t\t double precision \"grid(NGP)\": array containing the spatial grid points !\t\t double precision \"potential(NGP)\": array containing the potential V(x_i) evaluated at !\t\t\t\t\t\t\t\tthe grid points x_i=grid(i) ! !\tOUTPUT: double precision \"hamiltonian(NGP,NGP): the Hamiltonian array! !----------------------------------------------------------------------------------------------- !\t! Programmer\tDate\t\t\tComments !----------------------------------------------------------------------------------------------- !\tF. Herrera\t\tMarh 25, 2013\tSolves 1D Harmonic Oscillator. units h=1. !\tF. Herrera\t\tMarch 26, 2013\tImplements intervals #1 and #2. !\tF. Herrera\t\tApril 1, 2013\tTested against Morse oscillator. !\t\t\t\t\t\tGeneralized for an arbitrary 1D radial potential. !----------------------------------------------------------------------------------------------- implicit none integer interval , i , j , NGP , indexA , indexB !! Enteros double precision step , pi , xmin , x , omega , m , De , aa , re double precision hamiltonian ( NGP , NGP ), grid ( NGP ), potential ( NGP ) pi = dacos ( - 1.d0 ) do i = 1 , NGP do j = 1 , NGP if ( i . ne . j ) then hamiltonian ( i , j ) = ( 0.5d0 / m ) * ( step ** ( - 2 )) * ( 2.d0 / ( dble ( i - j ) ** 2 ) - 2.d0 / ( dble ( i + j ) ** 2 )) * ( - 1.d0 ) ** ( i - j ) end if end do hamiltonian ( i , i ) = ( 0.5d0 / m ) * ( step ** ( - 2 )) * ( pi * pi / 3.d0 - 0.5d0 / dble ( i * i )) + potential ( i ) end do end subroutine DVR_radial !================================================================================================================================================== subroutine orthonormal_check ( indexA , indexB , NGP , grid , eigenvectors ) implicit none integer i , NGP , indexA , indexB double precision grid ( NGP ), eigenvectors ( NGP , NGP ) !variables for cubic integration integer ntab , ia , ib real norm , error real , allocatable :: ftab (:), xtab (:) ntab = NGP ia = 1 ib = NGP allocate ( ftab ( ntab )) allocate ( xtab ( ntab )) do i = 1 , ntab xtab ( i ) = grid ( i ) ftab ( i ) = eigenvectors ( i , indexA ) * eigenvectors ( i , indexB ) end do call cubint ( ftab , xtab , ntab , ia , ib , norm , error ) write ( 6 , '(2(A,X,F9.6,X))' ) 'scalar product = ' , norm , 'error = ' , error write ( 6 , * ) end subroutine orthonormal_check !================================================================================================================================================== subroutine dunham ( NVS , energies ) ! specific for (7)Li(133)Cs from PRA 75, 042513 (2007) ! Assuming no rotational excitations J = 0, the energy of the vibrational state (in cm-1) is given by ! E(v,0) = w(v+1/2) -wx(v+1/2)&#94;2 + wy(v+1/2)&#94;3 + ... implicit none integer NVS , v , i double precision energies ( NVS ), a , b , c , d , e , f , g , h , x a = 0.18469891d3 ! Y1,0 = w b = - 0.10002506d1 ! Y2,0 = -wx c = - 0.13394d-2 ! Y3,0 = wy d = - 0.6965d-4 ! Y4,0 e = - 0.65721d-9 ! Y7,0 f = 0.163d-13 ! Y10,0 g = - 0.499d-15 ! Y11,0 h = 0.443d-17 ! Y12,0 do i = 1 , NVS v = dble ( i - 1 ) x = v + 0.5d0 energies ( i ) = a * x + b * x ** 2 + c * x ** 3 + d * x ** 4 + e * x ** 7 + f * x ** 10 + g * x ** 11 + h * x ** 12 end do end subroutine !==================================================================================================================================================","tags":"","loc":"sourcefile/rovib.f90.html"},{"title":"spline.f90 – Fortran Program","text":"Contents Subroutines cubicsplines splineinterpol locate Source Code spline.f90 Source Code subroutine cubicsplines ( knots , n , y0prime , ynprime , moments ) !\tGenerates the moments of the cubic splines used to generate interpolation polynomials between two subsequent points !\tin a given table of of N coordinate pairs. We use the condition at the boundaries that the first derivatives are known. !\tSee J. Stoer 'Introduction to Numerical Analysis', section 2.4. implicit none !\tLocal variables Integer :: n , i Double precision :: knots ( n , 2 ), upperdiag ( n - 1 ), lowerdiag ( n - 1 ), maindiag ( n ), rhsvector ( n ), moments ( n ) Double precision :: x0 , y0 , xn , yn , h1 , hn , up0 , lowN , b , bn , y0prime , ynprime !\tExternal subroutine variables integer :: INFO h1 = knots ( 2 , 1 ) - knots ( 1 , 1 ) hn = knots ( n , 1 ) - knots ( n - 1 , 1 ) b = 6.d0 / h1 * (( knots ( 2 , 2 ) - knots ( 1 , 2 )) / h1 - y0prime ) bn = 6.d0 / hn * ( ynprime - ( knots ( n , 2 ) - knots ( n - 1 , 2 )) / hn ) do i = 1 , n ! generate arrays of dimension n and dimension n-1 if ( i . eq . 1 ) then rhsvector ( i ) = b upperdiag ( i ) = 1.d0 else if ( i . eq . n ) then rhsvector ( i ) = bn !\t  lowerdiag(i) = 1.d0 else if (( i . ge . 2 ). AND .( i . le . n - 1 )) then rhsvector ( i ) = ( 6.d0 / ( knots ( i + 1 , 1 ) - knots ( i - 1 , 1 ))) * (( knots ( i + 1 , 2 ) - knots ( i , 2 )) / ( knots ( i + 1 , 1 ) - knots ( i , 1 )) & - ( knots ( i , 2 ) - knots ( i - 1 , 2 )) / ( knots ( i , 1 ) - knots ( i - 1 , 1 ))) upperdiag ( i ) = ( knots ( i + 1 , 1 ) - knots ( i , 1 )) / ( knots ( i + 1 , 1 ) - knots ( i - 1 , 1 )) lowerdiag ( i ) = 1.d0 - upperdiag ( i ) end if end do do i = 1 , n maindiag ( i ) = 2.d0 end do call dgtsv ( n , 1 , lowerdiag , maindiag , upperdiag , rhsvector , n , INFO ) if ( info . eq . 0 ) then moments = rhsvector else print * , '--- Error in the calculation of moments' end if end subroutine cubicsplines !======================================================== subroutine splineinterpol ( knots , moments , n , x , y ) !\tEvaluate the spline for the interval to which x belongs and returns the interpolated value. !\tSee J. Stoer 'Introduction to Numerical Analysis', section 2.4. implicit none !\tlocal variables integer :: j , n , i double precision :: x , xj , y , a , b , c , d double precision :: moments ( n ), knots ( n , 2 ) !\texternal subroutine variables double precision :: array ( n ) do i = 1 , n array ( i ) = knots ( i , 1 ) end do call locate ( Array , n , x , j ) a = knots ( j , 2 ) b = ( knots ( j + 1 , 2 ) - knots ( j , 2 )) / ( knots ( j + 1 , 1 ) - knots ( j , 1 )) - ( 2.d0 * moments ( j ) + moments ( j + 1 )) * ( knots ( j + 1 , 1 ) - knots ( j , 1 )) / 6.d0 c = moments ( j ) / 2.d0 d = ( moments ( j + 1 ) - moments ( j )) / ( 6.d0 * ( knots ( j + 1 , 1 ) - knots ( j , 1 ))) xj = knots ( j , 1 ) y = a + b * ( x - xj ) + c * ( x - xj ) ** 2 + d * ( x - xj ) ** 3 end subroutine splineinterpol !======================================================== subroutine locate ( grid , n , x , j ) !Array grid(n) must be in monotonically ascending order. !Subroutine gives the lower index of the smallest interval that includes x. ! The search is done by bisection. implicit none integer :: n , j , jm , jup , jlow , i double precision :: x double precision :: grid ( n ) jup = n jlow = 1 if ( x . gt .( grid ( n )). or .( x . lt . grid ( 1 ))) then WRITE ( * , '(A)' ) 'locate - error - value to interpolate outside range of data' WRITE ( * , '(A,F10.5)' ) 'x = ' , real ( x ) STOP end if If ( DABS ( grid ( 1 ) - x ). lt . 1 d - 9 ) then j = 1 else if ( DABS ( grid ( n ) - x ). lt . 1 d - 9 ) then j = n - 1 else do if ( jup - jlow . gt . 1 ) then jm = ( jup + jlow ) / 2 if (( x . gt . grid ( jlow )). and .( x . lt . grid ( jm ))) then jup = jm end if if (( x . gt . grid ( jm )). and .( x . lt . grid ( jup ))) then jlow = jm end if if ( DABS ( grid ( jm ) - x ). lt . 1 d - 9 ) then j = jm exit end if else j = jlow exit end if end do end if end subroutine locate","tags":"","loc":"sourcefile/spline.f90.html"},{"title":"unit_conversion.f90 – Fortran Program","text":"Files dependent on this one sourcefile~~unit_conversion.f90~~AfferentGraph sourcefile~unit_conversion.f90 unit_conversion.f90 sourcefile~rovib.f90 rovib.f90 sourcefile~rovib.f90->sourcefile~unit_conversion.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules unit_conversion_library Source Code unit_conversion.f90 Source Code MODULE unit_conversion_library CONTAINS !----------------------------------------------------- !\t\t\tENERGY !----------------------------------------------------- function hertz_to_hartree ( x ) implicit none double precision :: hertz_to_hartree double precision :: x hertz_to_hartree = x * 1.519829846006d-16 end function hertz_to_hartree !----------------------------------------------------- function hartree_to_hertz ( x ) implicit none double precision :: hartree_to_hertz double precision :: x hartree_to_hertz = x / 1.519829846006d-16 end function hartree_to_hertz !----------------------------------------------------- function joule_to_hartree ( x ) implicit none double precision :: joule_to_hartree double precision :: x joule_to_hartree = x * 2.29371269d17 end function joule_to_hartree !----------------------------------------------------- function wavenumber_to_hartree ( x ) implicit none double precision :: wavenumber_to_hartree double precision :: x wavenumber_to_hartree = x / 21947 4.63067d0 end function wavenumber_to_hartree !----------------------------------------------------- function hartree_to_wavenumber ( x ) implicit none double precision :: hartree_to_wavenumber double precision :: x hartree_to_wavenumber = x * 21947 4.63067d0 end function hartree_to_wavenumber !----------------------------------------------------- !\t\t\tDISTANCE !----------------------------------------------------- function meter_to_au ( x ) implicit none double precision :: meter_to_au double precision :: x meter_to_au = 1.889726133921252d10 * x end function meter_to_au !----------------------------------------------------- function au_to_meter ( x ) implicit none double precision :: au_to_meter double precision :: x au_to_meter = x / 1.889726133921252d10 end function au_to_meter !----------------------------------------------------- function angstrom_to_au ( x ) implicit none double precision :: angstrom_to_au double precision :: x angstrom_to_au = 1.889726133921252 * x end function angstrom_to_au !----------------------------------------------------- function au_to_angstrom ( x ) implicit none double precision :: au_to_angstrom double precision :: x au_to_angstrom = x / 1.889726133921252 end function au_to_angstrom !----------------------------------------------------- function nanometer_to_au ( x ) implicit none double precision :: nanometer_to_au double precision :: x nanometer_to_au = 1 8.89726133921252 * x end function nanometer_to_au !----------------------------------------------------- function au_to_nanometer ( x ) implicit none double precision :: au_to_nanometer double precision :: x au_to_nanometer = x / 1 8.89726133921252 end function au_to_nanometer !----------------------------------------------------- function inversenanometer_to_au ( x ) implicit none double precision :: inversenanometer_to_au double precision :: x inversenanometer_to_au = x / 1 8.89726133921252 end function inversenanometer_to_au !----------------------------------------------------- function au_to_inversenanometer ( x ) implicit none double precision :: au_to_inversenanometer double precision :: x au_to_inversenanometer = x * 1 8.89726133921252 end function au_to_inversenanometer !----------------------------------------------------- !\t\t\tTIME !----------------------------------------------------- function second_to_au ( x ) implicit none double precision :: second_to_au double precision :: x second_to_au = 4.134137337414122d16 * x end function second_to_au !----------------------------------------------------- function au_to_second ( x ) implicit none double precision :: au_to_second double precision :: x au_to_second = x / 4.134137337414122d16 end function au_to_second !----------------------------------------------------- !\t\t\tMASS !----------------------------------------------------- function amu_to_au ( x ) implicit none double precision :: amu_to_au double precision :: x amu_to_au = x * 182 2.888479031408 end function amu_to_au !----------------------------------------------------- !\t\t\tMAGNETIC FIELD !----------------------------------------------------- function gauss_to_au ( x ) implicit none double precision :: gauss_to_au double precision :: x gauss_to_au = x * 4.254382547308656d-10 end function gauss_to_au !----------------------------------------------------- !\t\t\tPOWER !----------------------------------------------------- function watt_to_au ( x ) implicit none double precision :: watt_to_au double precision :: x watt_to_au = x * 5.548225828243671 end function watt_to_au !----------------------------------------------------- !----------------------------------------------------- !\t\tDIPOLE MOMENT !----------------------------------------------------- function debye_to_au ( x ) implicit none double precision :: debye_to_au double precision :: x debye_to_au = x * 0.393430165d0 end function debye_to_au !----------------------------------------------------- function au_to_debye ( x ) implicit none double precision :: au_to_debye double precision :: x au_to_debye = x / 0.393430165d0 end function au_to_debye !----------------------------------------------------- END MODULE unit_conversion_library","tags":"","loc":"sourcefile/unit_conversion.f90.html"},{"title":"threejsymbol – Fortran Program","text":"function threejsymbol(j1, j2, j3, m1, m2, m3) Arguments Type Intent Optional Attributes Name real :: j1 real :: j2 real :: j3 real :: m1 real :: m2 real :: m3 Return Value real(kind=8) Calls proc~~threejsymbol~~CallsGraph proc~threejsymbol threejsymbol proc~add_sub add_sub proc~threejsymbol->proc~add_sub proc~decomp decomp proc~threejsymbol->proc~decomp proc~store store proc~threejsymbol->proc~store proc~binom1 binom1 proc~threejsymbol->proc~binom1 proc~find_prime find_prime proc~threejsymbol->proc~find_prime proc~mul mul proc~threejsymbol->proc~mul proc~binom binom proc~threejsymbol->proc~binom proc~mul_div mul_div proc~threejsymbol->proc~mul_div proc~load load proc~threejsymbol->proc~load proc~divs divs proc~threejsymbol->proc~divs proc~muls muls proc~threejsymbol->proc~muls proc~delta2 delta2 proc~threejsymbol->proc~delta2 proc~decomp->proc~store proc~decomp->proc~load proc~decomp->proc~divs proc~binom1->proc~mul_div proc~decomp1 decomp1 proc~binom1->proc~decomp1 float float proc~find_prime->float proc~mul->proc~add_sub proc~mul->proc~store proc~mul->proc~load proc~mul->proc~muls proc~binom->proc~store proc~binom->proc~load proc~binom->proc~divs proc~binom->proc~muls proc~delta2->proc~binom1 proc~delta2->proc~mul_div proc~delta2->proc~decomp1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Common Blocks mc pr Common Blocks common /mc/ Type Attributes Name Initial integer :: iac (length) integer :: sign common /pr/ Type Attributes Name Initial integer :: prime (ndim)","tags":"","loc":"proc/threejsymbol.html"},{"title":"sixj – Fortran Program","text":"function sixj(a, b, c, d, e, f) Arguments Type Intent Optional Attributes Name real :: a real :: b real :: c real :: d real :: e real :: f Return Value real(kind=8) Calls proc~~sixj~~CallsGraph proc~sixj sixj proc~add_sub add_sub proc~sixj->proc~add_sub proc~decomp decomp proc~sixj->proc~decomp proc~store store proc~sixj->proc~store proc~find_prime find_prime proc~sixj->proc~find_prime proc~mul mul proc~sixj->proc~mul proc~binom binom proc~sixj->proc~binom proc~mul_div mul_div proc~sixj->proc~mul_div proc~load load proc~sixj->proc~load proc~divs divs proc~sixj->proc~divs proc~muls muls proc~sixj->proc~muls proc~delta2 delta2 proc~sixj->proc~delta2 proc~decomp->proc~store proc~decomp->proc~load proc~decomp->proc~divs float float proc~find_prime->float proc~mul->proc~add_sub proc~mul->proc~store proc~mul->proc~load proc~mul->proc~muls proc~binom->proc~store proc~binom->proc~load proc~binom->proc~divs proc~binom->proc~muls proc~delta2->proc~mul_div proc~binom1 binom1 proc~delta2->proc~binom1 proc~decomp1 decomp1 proc~delta2->proc~decomp1 proc~binom1->proc~mul_div proc~binom1->proc~decomp1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Common Blocks mc pr Common Blocks common /mc/ Type Attributes Name Initial integer :: iac (length) integer :: sign common /pr/ Type Attributes Name Initial integer :: prime (ndim)","tags":"","loc":"proc/sixj.html"},{"title":"ninej – Fortran Program","text":"function ninej(a, b, c, d, e, f, g, h, j) Arguments Type Intent Optional Attributes Name real :: a real :: b real :: c real :: d real :: e real :: f real :: g real :: h real :: j Return Value real(kind=8) Calls proc~~ninej~~CallsGraph proc~ninej ninej proc~add_sub add_sub proc~ninej->proc~add_sub amin1 amin1 proc~ninej->amin1 proc~decomp decomp proc~ninej->proc~decomp proc~store store proc~ninej->proc~store proc~find_prime find_prime proc~ninej->proc~find_prime proc~mul mul proc~ninej->proc~mul proc~mul_div mul_div proc~ninej->proc~mul_div proc~load load proc~ninej->proc~load proc~factor factor proc~ninej->proc~factor proc~muls muls proc~ninej->proc~muls amax1 amax1 proc~ninej->amax1 proc~delta2 delta2 proc~ninej->proc~delta2 proc~decomp->proc~store proc~decomp->proc~load proc~divs divs proc~decomp->proc~divs float float proc~find_prime->float proc~mul->proc~add_sub proc~mul->proc~store proc~mul->proc~load proc~mul->proc~muls proc~factor->proc~add_sub proc~factor->proc~store proc~factor->proc~mul proc~factor->proc~load proc~factor->proc~muls proc~binom binom proc~factor->proc~binom proc~factor->proc~divs proc~delta2->proc~mul_div proc~binom1 binom1 proc~delta2->proc~binom1 proc~decomp1 decomp1 proc~delta2->proc~decomp1 proc~binom1->proc~mul_div proc~binom1->proc~decomp1 proc~binom->proc~store proc~binom->proc~load proc~binom->proc~muls proc~binom->proc~divs Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Common Blocks mc pr Common Blocks common /mc/ Type Attributes Name Initial integer :: iac (length) integer :: sign common /pr/ Type Attributes Name Initial integer :: prime (ndim)","tags":"","loc":"proc/ninej.html"},{"title":"factor – Fortran Program","text":"subroutine factor(a, b, c, d, e, f, sum) Arguments Type Intent Optional Attributes Name real :: a real :: b real :: c real :: d real :: e real :: f integer :: sum (length) Calls proc~~factor~~CallsGraph proc~factor factor proc~add_sub add_sub proc~factor->proc~add_sub proc~store store proc~factor->proc~store proc~mul mul proc~factor->proc~mul proc~binom binom proc~factor->proc~binom proc~load load proc~factor->proc~load proc~divs divs proc~factor->proc~divs proc~muls muls proc~factor->proc~muls proc~mul->proc~add_sub proc~mul->proc~store proc~mul->proc~load proc~mul->proc~muls proc~binom->proc~store proc~binom->proc~load proc~binom->proc~divs proc~binom->proc~muls Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~factor~~CalledByGraph proc~factor factor proc~ninej ninej proc~ninej->proc~factor Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Common Blocks mc Common Blocks common /mc/ Type Attributes Name Initial integer :: iac (length) integer :: sign","tags":"","loc":"proc/factor.html"},{"title":"load – Fortran Program","text":"subroutine load(ix) Arguments Type Intent Optional Attributes Name integer :: ix (length) Called by proc~~load~~CalledByGraph proc~load load proc~decomp decomp proc~decomp->proc~load proc~ninej ninej proc~ninej->proc~load proc~ninej->proc~decomp proc~mul mul proc~ninej->proc~mul proc~factor factor proc~ninej->proc~factor proc~mul->proc~load proc~binom binom proc~binom->proc~load proc~threejsymbol threejsymbol proc~threejsymbol->proc~load proc~threejsymbol->proc~decomp proc~threejsymbol->proc~mul proc~threejsymbol->proc~binom proc~factor->proc~load proc~factor->proc~mul proc~factor->proc~binom proc~sixj sixj proc~sixj->proc~load proc~sixj->proc~decomp proc~sixj->proc~mul proc~sixj->proc~binom Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Common Blocks mc Common Blocks common /mc/ Type Attributes Name Initial integer :: iac (length) integer :: sign","tags":"","loc":"proc/load.html"},{"title":"store – Fortran Program","text":"subroutine store(ix) Arguments Type Intent Optional Attributes Name integer :: ix (length) Called by proc~~store~~CalledByGraph proc~store store proc~decomp decomp proc~decomp->proc~store proc~ninej ninej proc~ninej->proc~store proc~ninej->proc~decomp proc~mul mul proc~ninej->proc~mul proc~factor factor proc~ninej->proc~factor proc~mul->proc~store proc~binom binom proc~binom->proc~store proc~threejsymbol threejsymbol proc~threejsymbol->proc~store proc~threejsymbol->proc~decomp proc~threejsymbol->proc~mul proc~threejsymbol->proc~binom proc~factor->proc~store proc~factor->proc~mul proc~factor->proc~binom proc~sixj sixj proc~sixj->proc~store proc~sixj->proc~decomp proc~sixj->proc~mul proc~sixj->proc~binom Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Common Blocks mc Common Blocks common /mc/ Type Attributes Name Initial integer :: iac (length) integer :: sign","tags":"","loc":"proc/store.html"},{"title":"add_sub – Fortran Program","text":"subroutine add_sub(ix) Arguments Type Intent Optional Attributes Name integer :: ix (length) Called by proc~~add_sub~~CalledByGraph proc~add_sub add_sub proc~ninej ninej proc~ninej->proc~add_sub proc~mul mul proc~ninej->proc~mul proc~factor factor proc~ninej->proc~factor proc~mul->proc~add_sub proc~threejsymbol threejsymbol proc~threejsymbol->proc~add_sub proc~threejsymbol->proc~mul proc~factor->proc~add_sub proc~factor->proc~mul proc~sixj sixj proc~sixj->proc~add_sub proc~sixj->proc~mul Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Common Blocks mc Common Blocks common /mc/ Type Attributes Name Initial integer :: iac (length) integer :: sign","tags":"","loc":"proc/add_sub.html"},{"title":"muls – Fortran Program","text":"subroutine muls(n) Arguments Type Intent Optional Attributes Name integer :: n Called by proc~~muls~~CalledByGraph proc~muls muls proc~ninej ninej proc~ninej->proc~muls proc~mul mul proc~ninej->proc~mul proc~factor factor proc~ninej->proc~factor proc~mul->proc~muls proc~binom binom proc~binom->proc~muls proc~threejsymbol threejsymbol proc~threejsymbol->proc~muls proc~threejsymbol->proc~mul proc~threejsymbol->proc~binom proc~factor->proc~muls proc~factor->proc~mul proc~factor->proc~binom proc~sixj sixj proc~sixj->proc~muls proc~sixj->proc~mul proc~sixj->proc~binom Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Common Blocks mc Common Blocks common /mc/ Type Attributes Name Initial integer :: iac (length) integer :: sign","tags":"","loc":"proc/muls.html"},{"title":"mul – Fortran Program","text":"subroutine mul(ix) Arguments Type Intent Optional Attributes Name integer :: ix (length) Calls proc~~mul~~CallsGraph proc~mul mul proc~add_sub add_sub proc~mul->proc~add_sub proc~store store proc~mul->proc~store proc~load load proc~mul->proc~load proc~muls muls proc~mul->proc~muls Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~mul~~CalledByGraph proc~mul mul proc~threejsymbol threejsymbol proc~threejsymbol->proc~mul proc~ninej ninej proc~ninej->proc~mul proc~factor factor proc~ninej->proc~factor proc~sixj sixj proc~sixj->proc~mul proc~factor->proc~mul Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Common Blocks mc Common Blocks common /mc/ Type Attributes Name Initial integer :: iac (length) integer :: sign","tags":"","loc":"proc/mul.html"},{"title":"divs – Fortran Program","text":"subroutine divs(n, m) Arguments Type Intent Optional Attributes Name integer :: n integer :: m Called by proc~~divs~~CalledByGraph proc~divs divs proc~decomp decomp proc~decomp->proc~divs proc~binom binom proc~binom->proc~divs proc~threejsymbol threejsymbol proc~threejsymbol->proc~divs proc~threejsymbol->proc~decomp proc~threejsymbol->proc~binom proc~factor factor proc~factor->proc~divs proc~factor->proc~binom proc~sixj sixj proc~sixj->proc~divs proc~sixj->proc~decomp proc~sixj->proc~binom proc~ninej ninej proc~ninej->proc~decomp proc~ninej->proc~factor Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Common Blocks mc Common Blocks common /mc/ Type Attributes Name Initial integer :: iac (length) integer :: sign","tags":"","loc":"proc/divs.html"},{"title":"binom – Fortran Program","text":"subroutine binom(n, m, ix) Arguments Type Intent Optional Attributes Name integer :: n integer :: m integer :: ix (length) Calls proc~~binom~~CallsGraph proc~binom binom proc~store store proc~binom->proc~store proc~load load proc~binom->proc~load proc~divs divs proc~binom->proc~divs proc~muls muls proc~binom->proc~muls Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~binom~~CalledByGraph proc~binom binom proc~threejsymbol threejsymbol proc~threejsymbol->proc~binom proc~sixj sixj proc~sixj->proc~binom proc~factor factor proc~factor->proc~binom proc~ninej ninej proc~ninej->proc~factor Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Common Blocks mc Common Blocks common /mc/ Type Attributes Name Initial integer :: iac (length) integer :: sign","tags":"","loc":"proc/binom.html"},{"title":"find_prime – Fortran Program","text":"subroutine find_prime() Arguments None Calls proc~~find_prime~~CallsGraph proc~find_prime find_prime float float proc~find_prime->float Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~find_prime~~CalledByGraph proc~find_prime find_prime proc~threejsymbol threejsymbol proc~threejsymbol->proc~find_prime proc~ninej ninej proc~ninej->proc~find_prime proc~sixj sixj proc~sixj->proc~find_prime Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Common Blocks pr Common Blocks common /pr/ Type Attributes Name Initial integer :: prime (ndim)","tags":"","loc":"proc/find_prime.html"},{"title":"decomp – Fortran Program","text":"subroutine decomp(power, k) Arguments Type Intent Optional Attributes Name integer :: power (ndim) integer :: k Calls proc~~decomp~~CallsGraph proc~decomp decomp proc~store store proc~decomp->proc~store proc~load load proc~decomp->proc~load proc~divs divs proc~decomp->proc~divs Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~decomp~~CalledByGraph proc~decomp decomp proc~threejsymbol threejsymbol proc~threejsymbol->proc~decomp proc~ninej ninej proc~ninej->proc~decomp proc~sixj sixj proc~sixj->proc~decomp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Common Blocks mc pr Common Blocks common /mc/ Type Attributes Name Initial integer :: iac (length) integer :: sign common /pr/ Type Attributes Name Initial integer :: prime (ndim)","tags":"","loc":"proc/decomp.html"},{"title":"decomp1 – Fortran Program","text":"subroutine decomp1(num, power, k) Arguments Type Intent Optional Attributes Name integer :: num integer :: power (ndim) integer :: k Called by proc~~decomp1~~CalledByGraph proc~decomp1 decomp1 proc~binom1 binom1 proc~binom1->proc~decomp1 proc~delta2 delta2 proc~delta2->proc~decomp1 proc~delta2->proc~binom1 proc~threejsymbol threejsymbol proc~threejsymbol->proc~binom1 proc~threejsymbol->proc~delta2 proc~ninej ninej proc~ninej->proc~delta2 proc~sixj sixj proc~sixj->proc~delta2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Common Blocks pr Common Blocks common /pr/ Type Attributes Name Initial integer :: prime (ndim)","tags":"","loc":"proc/decomp1.html"},{"title":"mul_div – Fortran Program","text":"subroutine mul_div(p_s, power1, k1, power2, k2, power, k) Arguments Type Intent Optional Attributes Name integer :: p_s integer :: power1 (k1) integer :: k1 integer :: power2 (k2) integer :: k2 integer :: power (k) integer :: k Called by proc~~mul_div~~CalledByGraph proc~mul_div mul_div proc~ninej ninej proc~ninej->proc~mul_div proc~delta2 delta2 proc~ninej->proc~delta2 proc~binom1 binom1 proc~binom1->proc~mul_div proc~threejsymbol threejsymbol proc~threejsymbol->proc~mul_div proc~threejsymbol->proc~binom1 proc~threejsymbol->proc~delta2 proc~sixj sixj proc~sixj->proc~mul_div proc~sixj->proc~delta2 proc~delta2->proc~mul_div proc~delta2->proc~binom1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/mul_div.html"},{"title":"binom1 – Fortran Program","text":"subroutine binom1(n, m, power, k) Arguments Type Intent Optional Attributes Name integer :: n integer :: m integer :: power (ndim) integer :: k Calls proc~~binom1~~CallsGraph proc~binom1 binom1 proc~decomp1 decomp1 proc~binom1->proc~decomp1 proc~mul_div mul_div proc~binom1->proc~mul_div Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~binom1~~CalledByGraph proc~binom1 binom1 proc~threejsymbol threejsymbol proc~threejsymbol->proc~binom1 proc~delta2 delta2 proc~threejsymbol->proc~delta2 proc~delta2->proc~binom1 proc~ninej ninej proc~ninej->proc~delta2 proc~sixj sixj proc~sixj->proc~delta2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/binom1.html"},{"title":"delta2 – Fortran Program","text":"subroutine delta2(a, b, c, power, k) Arguments Type Intent Optional Attributes Name real :: a real :: b real :: c integer :: power (ndim) integer :: k Calls proc~~delta2~~CallsGraph proc~delta2 delta2 proc~decomp1 decomp1 proc~delta2->proc~decomp1 proc~binom1 binom1 proc~delta2->proc~binom1 proc~mul_div mul_div proc~delta2->proc~mul_div proc~binom1->proc~decomp1 proc~binom1->proc~mul_div Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~delta2~~CalledByGraph proc~delta2 delta2 proc~threejsymbol threejsymbol proc~threejsymbol->proc~delta2 proc~ninej ninej proc~ninej->proc~delta2 proc~sixj sixj proc~sixj->proc~delta2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/delta2.html"},{"title":"cubint – Fortran Program","text":"subroutine cubint(ftab, xtab, ntab, ia, ib, result, error) CUBINT approximates an integral using cubic interpolation of data. Arguments Type Intent Optional Attributes Name real(kind=8) :: ftab (ntab) real(kind=8) :: xtab (ntab) integer :: ntab integer :: ia integer :: ib real(kind=8) :: result real(kind=8) :: error Called by proc~~cubint~~CalledByGraph proc~cubint cubint proc~orthonormal_check orthonormal_check proc~orthonormal_check->proc~cubint Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/cubint.html"},{"title":"DVR_radial – Fortran Program","text":"subroutine DVR_radial(m, step, NGP, grid, potential, hamiltonian) Arguments Type Intent Optional Attributes Name double precision :: m double precision :: step integer :: NGP Enteros double precision :: grid (NGP) double precision :: potential (NGP) double precision :: hamiltonian (NGP,NGP) Calls proc~~dvr_radial~~CallsGraph proc~dvr_radial DVR_radial dacos dacos proc~dvr_radial->dacos Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~dvr_radial~~CalledByGraph proc~dvr_radial DVR_radial program~rovib rovib program~rovib->proc~dvr_radial Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/dvr_radial.html"},{"title":"orthonormal_check – Fortran Program","text":"subroutine orthonormal_check(indexA, indexB, NGP, grid, eigenvectors) Arguments Type Intent Optional Attributes Name integer :: indexA integer :: indexB integer :: NGP double precision :: grid (NGP) double precision :: eigenvectors (NGP,NGP) Calls proc~~orthonormal_check~~CallsGraph proc~orthonormal_check orthonormal_check proc~cubint cubint proc~orthonormal_check->proc~cubint Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/orthonormal_check.html"},{"title":"dunham – Fortran Program","text":"subroutine dunham(NVS, energies) Arguments Type Intent Optional Attributes Name integer :: NVS double precision :: energies (NVS) Contents None","tags":"","loc":"proc/dunham.html"},{"title":"cubicsplines – Fortran Program","text":"subroutine cubicsplines(knots, n, y0prime, ynprime, moments) Arguments Type Intent Optional Attributes Name double precision :: knots (n,2) integer :: n double precision :: y0prime double precision :: ynprime double precision :: moments (n) Calls proc~~cubicsplines~~CallsGraph proc~cubicsplines cubicsplines dgtsv dgtsv proc~cubicsplines->dgtsv Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~cubicsplines~~CalledByGraph proc~cubicsplines cubicsplines program~rovib rovib program~rovib->proc~cubicsplines Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/cubicsplines.html"},{"title":"splineinterpol – Fortran Program","text":"subroutine splineinterpol(knots, moments, n, x, y) Arguments Type Intent Optional Attributes Name double precision :: knots (n,2) double precision :: moments (n) integer :: n double precision :: x double precision :: y Calls proc~~splineinterpol~~CallsGraph proc~splineinterpol splineinterpol proc~locate locate proc~splineinterpol->proc~locate Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~splineinterpol~~CalledByGraph proc~splineinterpol splineinterpol program~rovib rovib program~rovib->proc~splineinterpol Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/splineinterpol.html"},{"title":"locate – Fortran Program","text":"subroutine locate(grid, n, x, j) Arguments Type Intent Optional Attributes Name double precision :: grid (n) integer :: n double precision :: x integer :: j Called by proc~~locate~~CalledByGraph proc~locate locate proc~splineinterpol splineinterpol proc~splineinterpol->proc~locate program~rovib rovib program~rovib->proc~splineinterpol Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/locate.html"},{"title":"hertz_to_hartree – Fortran Program","text":"public function hertz_to_hartree(x) Arguments Type Intent Optional Attributes Name double precision :: x Return Value double precision Contents None","tags":"","loc":"proc/hertz_to_hartree.html"},{"title":"hartree_to_hertz – Fortran Program","text":"public function hartree_to_hertz(x) Arguments Type Intent Optional Attributes Name double precision :: x Return Value double precision Contents None","tags":"","loc":"proc/hartree_to_hertz.html"},{"title":"joule_to_hartree – Fortran Program","text":"public function joule_to_hartree(x) Arguments Type Intent Optional Attributes Name double precision :: x Return Value double precision Contents None","tags":"","loc":"proc/joule_to_hartree.html"},{"title":"wavenumber_to_hartree – Fortran Program","text":"public function wavenumber_to_hartree(x) Arguments Type Intent Optional Attributes Name double precision :: x Return Value double precision Called by proc~~wavenumber_to_hartree~~CalledByGraph proc~wavenumber_to_hartree wavenumber_to_hartree program~rovib rovib program~rovib->proc~wavenumber_to_hartree Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/wavenumber_to_hartree.html"},{"title":"hartree_to_wavenumber – Fortran Program","text":"public function hartree_to_wavenumber(x) Arguments Type Intent Optional Attributes Name double precision :: x Return Value double precision Contents None","tags":"","loc":"proc/hartree_to_wavenumber.html"},{"title":"meter_to_au – Fortran Program","text":"public function meter_to_au(x) Arguments Type Intent Optional Attributes Name double precision :: x Return Value double precision Contents None","tags":"","loc":"proc/meter_to_au.html"},{"title":"au_to_meter – Fortran Program","text":"public function au_to_meter(x) Arguments Type Intent Optional Attributes Name double precision :: x Return Value double precision Contents None","tags":"","loc":"proc/au_to_meter.html"},{"title":"angstrom_to_au – Fortran Program","text":"public function angstrom_to_au(x) Arguments Type Intent Optional Attributes Name double precision :: x Return Value double precision Contents None","tags":"","loc":"proc/angstrom_to_au.html"},{"title":"au_to_angstrom – Fortran Program","text":"public function au_to_angstrom(x) Arguments Type Intent Optional Attributes Name double precision :: x Return Value double precision Contents None","tags":"","loc":"proc/au_to_angstrom.html"},{"title":"nanometer_to_au – Fortran Program","text":"public function nanometer_to_au(x) Arguments Type Intent Optional Attributes Name double precision :: x Return Value double precision Contents None","tags":"","loc":"proc/nanometer_to_au.html"},{"title":"au_to_nanometer – Fortran Program","text":"public function au_to_nanometer(x) Arguments Type Intent Optional Attributes Name double precision :: x Return Value double precision Contents None","tags":"","loc":"proc/au_to_nanometer.html"},{"title":"inversenanometer_to_au – Fortran Program","text":"public function inversenanometer_to_au(x) Arguments Type Intent Optional Attributes Name double precision :: x Return Value double precision Contents None","tags":"","loc":"proc/inversenanometer_to_au.html"},{"title":"au_to_inversenanometer – Fortran Program","text":"public function au_to_inversenanometer(x) Arguments Type Intent Optional Attributes Name double precision :: x Return Value double precision Contents None","tags":"","loc":"proc/au_to_inversenanometer.html"},{"title":"second_to_au – Fortran Program","text":"public function second_to_au(x) Arguments Type Intent Optional Attributes Name double precision :: x Return Value double precision Contents None","tags":"","loc":"proc/second_to_au.html"},{"title":"au_to_second – Fortran Program","text":"public function au_to_second(x) Arguments Type Intent Optional Attributes Name double precision :: x Return Value double precision Contents None","tags":"","loc":"proc/au_to_second.html"},{"title":"amu_to_au – Fortran Program","text":"public function amu_to_au(x) Arguments Type Intent Optional Attributes Name double precision :: x Return Value double precision Called by proc~~amu_to_au~~CalledByGraph proc~amu_to_au amu_to_au program~rovib rovib program~rovib->proc~amu_to_au Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/amu_to_au.html"},{"title":"gauss_to_au – Fortran Program","text":"public function gauss_to_au(x) Arguments Type Intent Optional Attributes Name double precision :: x Return Value double precision Contents None","tags":"","loc":"proc/gauss_to_au.html"},{"title":"watt_to_au – Fortran Program","text":"public function watt_to_au(x) Arguments Type Intent Optional Attributes Name double precision :: x Return Value double precision Contents None","tags":"","loc":"proc/watt_to_au.html"},{"title":"debye_to_au – Fortran Program","text":"public function debye_to_au(x) Arguments Type Intent Optional Attributes Name double precision :: x Return Value double precision Contents None","tags":"","loc":"proc/debye_to_au.html"},{"title":"au_to_debye – Fortran Program","text":"public function au_to_debye(x) Arguments Type Intent Optional Attributes Name double precision :: x Return Value double precision Contents None","tags":"","loc":"proc/au_to_debye.html"},{"title":"unit_conversion_library – Fortran Program","text":"Used by module~~unit_conversion_library~~UsedByGraph module~unit_conversion_library unit_conversion_library program~rovib rovib program~rovib->module~unit_conversion_library Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Functions hertz_to_hartree hartree_to_hertz joule_to_hartree wavenumber_to_hartree hartree_to_wavenumber meter_to_au au_to_meter angstrom_to_au au_to_angstrom nanometer_to_au au_to_nanometer inversenanometer_to_au au_to_inversenanometer second_to_au au_to_second amu_to_au gauss_to_au watt_to_au debye_to_au au_to_debye Functions public function hertz_to_hartree (x) Arguments Type Intent Optional Attributes Name double precision :: x Return Value double precision public function hartree_to_hertz (x) Arguments Type Intent Optional Attributes Name double precision :: x Return Value double precision public function joule_to_hartree (x) Arguments Type Intent Optional Attributes Name double precision :: x Return Value double precision public function wavenumber_to_hartree (x) Arguments Type Intent Optional Attributes Name double precision :: x Return Value double precision public function hartree_to_wavenumber (x) Arguments Type Intent Optional Attributes Name double precision :: x Return Value double precision public function meter_to_au (x) Arguments Type Intent Optional Attributes Name double precision :: x Return Value double precision public function au_to_meter (x) Arguments Type Intent Optional Attributes Name double precision :: x Return Value double precision public function angstrom_to_au (x) Arguments Type Intent Optional Attributes Name double precision :: x Return Value double precision public function au_to_angstrom (x) Arguments Type Intent Optional Attributes Name double precision :: x Return Value double precision public function nanometer_to_au (x) Arguments Type Intent Optional Attributes Name double precision :: x Return Value double precision public function au_to_nanometer (x) Arguments Type Intent Optional Attributes Name double precision :: x Return Value double precision public function inversenanometer_to_au (x) Arguments Type Intent Optional Attributes Name double precision :: x Return Value double precision public function au_to_inversenanometer (x) Arguments Type Intent Optional Attributes Name double precision :: x Return Value double precision public function second_to_au (x) Arguments Type Intent Optional Attributes Name double precision :: x Return Value double precision public function au_to_second (x) Arguments Type Intent Optional Attributes Name double precision :: x Return Value double precision public function amu_to_au (x) Arguments Type Intent Optional Attributes Name double precision :: x Return Value double precision public function gauss_to_au (x) Arguments Type Intent Optional Attributes Name double precision :: x Return Value double precision public function watt_to_au (x) Arguments Type Intent Optional Attributes Name double precision :: x Return Value double precision public function debye_to_au (x) Arguments Type Intent Optional Attributes Name double precision :: x Return Value double precision public function au_to_debye (x) Arguments Type Intent Optional Attributes Name double precision :: x Return Value double precision","tags":"","loc":"module/unit_conversion_library.html"},{"title":"rovib – Fortran Program","text":"Uses unit_conversion_library program~~rovib~~UsesGraph program~rovib rovib module~unit_conversion_library unit_conversion_library program~rovib->module~unit_conversion_library Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Calls program~~rovib~~CallsGraph program~rovib rovib proc~splineinterpol splineinterpol program~rovib->proc~splineinterpol proc~amu_to_au amu_to_au program~rovib->proc~amu_to_au proc~wavenumber_to_hartree wavenumber_to_hartree program~rovib->proc~wavenumber_to_hartree proc~dvr_radial DVR_radial program~rovib->proc~dvr_radial dsyevd dsyevd program~rovib->dsyevd proc~cubicsplines cubicsplines program~rovib->proc~cubicsplines proc~locate locate proc~splineinterpol->proc~locate dacos dacos proc~dvr_radial->dacos dgtsv dgtsv proc~cubicsplines->dgtsv Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables NGP i j rot instatus vmax NV NR PEC kmax NN Nmax mass rmin rmax step RMAT grid potential hamiltonian eigenvalues eigenvectors rovib_wavefunctions rovib_energies mol WORK A IWORK LWORK LIWORK INFO mesh x y knots moments threejsymbol Variables Type Attributes Name Initial integer :: NGP integer :: i integer :: j integer :: rot integer :: instatus integer :: vmax integer :: NV integer :: NR integer :: PEC integer, parameter :: kmax = 5000 double precision :: NN double precision :: Nmax double precision :: mass double precision :: rmin double precision :: rmax double precision :: step double precision :: RMAT (kmax,2) double precision, allocatable :: grid (:) double precision, allocatable :: potential (:) double precision, allocatable :: hamiltonian (:,:) double precision, allocatable :: eigenvalues (:) double precision, allocatable :: eigenvectors (:,:) double precision, allocatable :: rovib_wavefunctions (:,:,:) double precision, allocatable :: rovib_energies (:,:) character :: mol *4 double precision, allocatable :: WORK (:) double precision, allocatable :: A (:,:) integer, allocatable :: IWORK (:) integer :: LWORK integer :: LIWORK integer :: INFO integer :: mesh double precision :: x double precision :: y double precision, allocatable :: knots (:,:) double precision, allocatable :: moments (:) real(kind=8) :: threejsymbol","tags":"","loc":"program/rovib.html"}]}